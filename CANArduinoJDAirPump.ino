/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/38723f22-1619-4775-a016-28a72aff1cfa

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String showMessage;
  float getPressure;
  float setPoint;
  bool vibration;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
  FLORO
  ID: 71f75ef0-e732-4bac-8f90-12b78b1ff9fb
  Secret: WR4GUXMZTVFTV2GC6QIM

  RAUL
  Device ID:
  98ef0f65-aa83-4b4b-a976-25e385bc4ebb
  Secret Key:
  KWGDZQPI5O46ILFSK5QD

*/
#include "thingProperties.h"
#include <mcp_can.h>
#include <SPI.h>

// RX pointers
#define sizeCharArray 128
#define rxPressure 7
#define rxErrorCounter 6
#define rxError 5
#define rxVibrator 4

int errorNumber = 0;
int canErrorCounter;
int rawPressure;
int compressor;

// CAN varibles
long unsigned int rxId;
unsigned char len = 0;
unsigned char rxBuf[8];

char msgString[sizeCharArray]; // Array to store serial string

// For ESP32
#define CAN0_INT 21 // Set INT to pin D21
MCP_CAN CAN0(5);    // Set CS to pin D5

byte data[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

void setup()
{
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  getPressure = 0;
  vibration = false;
  showMessage = "";
  setPoint = 0.0;
  compressor = 0;
  canErrorCounter = 0;
  compressor = 0;

  // Initialize MCP2515 running at 8MHz with a baudrate of 1000kb/s and the masks and filters disabled.
  if (CAN0.begin(MCP_ANY, CAN_1000KBPS, MCP_8MHZ) == CAN_OK)
    Serial.println("MCP2515 Initialized Successfully!");
  else
    Serial.println("Error Initializing MCP2515...");

  CAN0.setMode(MCP_NORMAL); // Set operation mode to normal so the MCP2515 sends acks to received data.

  pinMode(CAN0_INT, INPUT); // Configuring pin for /INT input

  Serial.println("Setup has finished");
}

void dashboard()
{
  // error handler
  // rxPressure 7
  // rxErrorCounter 6
  // rxError 5
  // rxVibrator 4

  errorNumber = rxBuf[rxError];

  // showMessage = "This error has happen :" ;
  // strcat(showMessage, sprintf(rxBuf[rxErrorCounter], "%c", 255);
  // strcat(showMessage, " times...");
  canErrorCounter = rxBuf[rxErrorCounter];

  if (errorNumber != 0)
  {
    compressor = 0;
  }

  switch (errorNumber)
  {
  case 0: // NO ERROR
    showMessage = "Inflating Tire";
    rawPressure = rxBuf[rxPressure];
    getPressure = rawPressure * 20.0 / 151.0;

    if (getPressure + 2 >= setPoint && getPressure - 1 <= setPoint)
    {
      getPressure = setPoint;
    }
    vibration = rxBuf[rxVibrator];

    if (getPressure < setPoint)
      compressor = 1;
    else
      compressor = 0;

    // delay(500);
    if (rxBuf[rxVibrator] == 1 and compressor == 1)
    {
      showMessage = "Tire...";
    }
    else if (rxBuf[rxVibrator] == 1 and compressor == 0 or rxBuf[rxVibrator] == 0 and compressor == 1)
    {
      Serial.println("Vibration Error");
    }

    break;
  case 1:
    Serial.println(showMessage);
    showMessage = "Data Valid but Above Normal Operational Range";
    break;
  case 2:
    Serial.println(showMessage);
    showMessage = "Data Valid but Below Normal Operational Range";
    break;
  case 3:
    Serial.println(showMessage);
    showMessage = "Data Erratic, Intermittent or Incorrect";
    break;
  case 4:
    Serial.println(showMessage);
    showMessage = "Voltage Above Normal, or Shorted to High Source";
    break;
  case 5:
    Serial.println(showMessage);
    showMessage = "Voltage Below Normal, or Shorted to Low Source";
    break;
  case 6:
    Serial.println(showMessage);
    showMessage = "Current Below Normal or Open Circuit";
    break;
  case 7:
    Serial.println(showMessage);
    showMessage = "Current Above Normal or Grounded Circuit";
    break;
  case 8:
    Serial.println(showMessage);
    showMessage = "Overload or Grounded Circuit"; // Software Fuse is blown
    break;
  }
  return;
}

void CAN()
{
  if (!digitalRead(CAN0_INT)) // If CAN0_INT pin is low, read receive buffer
  {
    CAN0.readMsgBuf(&rxId, &len, rxBuf); // Read data: len = data length, buf = data byte(s)
    dashboard();

    if ((rxId & 0x80000000) == 0x80000000) // Determine if ID is standard (11 bits) or extended (29 bits)
      sprintf(msgString, "Extended ID: 0x%.8lX  DLC: %1d  Data:", (rxId & 0x1FFFFFFF), len);
    else
      sprintf(msgString, "Standard ID: 0x%.3lX       DLC: %1d  Data:", rxId, len);

    Serial.print(msgString);

    if ((rxId & 0x40000000) == 0x40000000)
    { // Determine if message is a remote request frame.
      sprintf(msgString, " REMOTE REQUEST FRAME");
      Serial.print(msgString);
    }
    else
    {
      for (byte i = 0; i < len; i++)
      {
        sprintf(msgString, " 0x%.2X", rxBuf[i]);
        Serial.print(msgString);
      }
    }

    Serial.println();
  }
  else
  {
    byte sndStat = CAN0.sendMsgBuf(0x255, 0, 8, data);
    if (sndStat == CAN_OK)
    {
      Serial.println("Message sent!");
    }
    else
    {
      Serial.println("Error sending message.");
    }
  }
  delay(200);
}

void loop()
{
  ArduinoCloud.update();
  if (setPoint > 20)
  {
    setPoint = 20;
  }
  else if (setPoint < 0)
  {
    setPoint = 0;
  }
  CAN();
}

/*
  Since SetPoint is READ_WRITE variable, onSetPointChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSetPointChange()
{
  // Add your code here to act upon SetPoint change
}

/*
  Since GetPressure is READ_WRITE variable, onGetPressureChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onGetPressureChange()
{
  // Add your code here to act upon GetPressure change
}

/*
  Since Vibration is READ_WRITE variable, onVibrationChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onVibrationChange()
{
  // Add your code here to act upon Vibration change
}

/*
  Since ShowMessage is READ_WRITE variable, onShowMessageChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onShowMessageChange()
{
  // Add your code here to act upon ShowMessage change
}
